#include "stringConv.h"#ifdef _WIN_NT#include "tchar.h"#include "winbase.h"#else#include <arpa/inet.h>#endif#ifdef APP_PLAYER_UI#include <algorithm>#endif#ifdef _WIN_NTLPSTR Unicode2UTF8(LPWSTR s){    DWORD dwNum= WideCharToMultiByte (CP_UTF8, 0, s, -1, NULL, 0,0,0);    LPSTR target=new char[dwNum];    WideCharToMultiByte(CP_UTF8,0,s,-1,target,dwNum,0,0);    return target;}LPSTR Unicode2Ansi(LPCWSTR s){    DWORD dwNum= WideCharToMultiByte (CP_ACP, 0, s, -1, NULL, 0,0,0);    LPSTR target=new char[dwNum];    WideCharToMultiByte(CP_ACP,0,s,-1,target,dwNum,0,0);    return target;}LPWSTR Ansi2Unicode(LPSTR s){    DWORD dwNum= MultiByteToWideChar (CP_ACP, 0,(LPCSTR) s, -1, NULL, 0);    LPWSTR target=new WCHAR[dwNum];    MultiByteToWideChar(CP_ACP,0,(LPCSTR)s,-1,target,dwNum);    return target;}LPWSTR UTF82Unicode(LPSTR s){    DWORD dwNum = MultiByteToWideChar (CP_UTF8, 0, s, -1, NULL, 0);    LPWSTR target=new WCHAR[dwNum];    MultiByteToWideChar(CP_UTF8,0,(LPCSTR)s,-1,target,dwNum);    return target;}#elsechar*  _itoa(int num , char *str , int radix){    /* 索引表 */    char index[]="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";    unsigned unum; /* 中间变量 */    int i=0,j,k;    /* 确定unum的值 */    if(radix==10&&num<0) /* 十进制负数 */    {        unum=(unsigned)-num;        str[i++]='-';    }    else unum=(unsigned)num; /* 其他情况 */    /* 逆序 */    do    {        str[i++]=index[unum%(unsigned)radix];        unum/=radix;    }while(unum);    str[i]='\0';    /* 转换 */    if(str[0]=='-') k=1; /* 十进制负数 */    else k=0;    /* 将原来的“/2”改为“/2.0”，保证当num在16~255之间，radix等于16时，也能得到正确结果 */    char temp;    for(j=k;j<=(i-k-1)/2.0;j++)    {        temp=str[j];        str[j]=str[i-j-1];        str[i-j-1]=temp;    }    return str;}// UTF-8的unicode表示方法到unicode的值转换函数int utf82unicode(unsigned int  byte[], int index, int count, char *out){    int i, len=0;    unsigned short unicode;        for (i=index; i < count; ++i)    {                if (index >= count) return len;        if ( (byte[index] & 0x80) == 0x0)              //  Ò»Î»        {            unicode = byte[index];            index=index+1;                    }        else if ((byte[index] & 0xE0) == 0xC0) // Á½Î»        {            if (index + 1 >= count ) return len;            unicode = (((int)(byte[index] & 0x1F)) << 6)            | (byte[ index + 1] & 0x3F);            index=index+2;        }        else if ((byte[index] & 0xF0) == 0xE0) // ÈýÎ»        {            if (index + 2 >= count) return len;            unicode = (((int)(byte[index] & 0x0F)) << 12)            | (((int)(byte[index  + 1] & 0x3F)) << 6)            | (byte[index + 2] & 0x3F);            index=index+3;        }        else if ((byte[index] & 0xF8) == 0xF0) // ËÄÎ»        {            if (index + 3 >= count) return len;            unicode = (((int)(byte[index] & 0x07)) << 18)            | (((int)(byte[index + 1] & 0x3F)) << 12)            | (((int)(byte[index + 2] & 0x3F)) << 6)            | (byte[index + 3] & 0x3F);            index=index+4;        }        else if ((byte[index] & 0xFC) == 0xF8) // ÎåÎ»        {            if (index + 4 >= count) return len;            unicode = (((int)(byte[index] & 0x03)) << 24)            | (((int)(byte[index + 1] & 0x3F)) << 18)            | (((int)(byte[index + 2] & 0x3F)) << 12)            | (((int)(byte[index + 3] & 0x3F)) << 6)            | (byte[index + 4] & 0x3F);            index=index+5;        }        else if ((byte[index] & 0xFE) == 0xFC) // ÁùÎ»        {            if (index + 5 >= count) return len;            unicode = (((int)(byte[index] & 0x01)) << 30)            | (((int)(byte[index + 1] & 0x3F)) << 24)            | (((int)(byte[index + 2] & 0x3F)) << 18)            | (((int)(byte[index + 3] & 0x3F)) << 12)            | (((int)(byte[index + 4] & 0x3F)) << 6)            | (byte[index + 5] & 0x3F);            index=index+6;        }        else        {            return len;        }                memcpy(&out[len] ,(char *)&unicode , 2 );        len=len+2;    }        return len;    }int char2digist(char in, int *out){    if ('0' <= in && in <= '9')        *out = in - '0' + 0x0;    else if ('A' <= in && in <= 'F')        *out = in - 'A' + 0xA;    else if ('a' <= in && in <= 'f')        *out = in - 'a' + 0xa;    else        return 0;        return 1;    }int widechar2hexbyte(char* ch, int index, int count, unsigned int *byte){    int h, l;    if (index + 1 < count) {        if (char2digist(ch[index], &h) && char2digist(ch[index + 1], &l))        {            *byte = ((unsigned int)(h << 4)) | l;            return 1;        }    } else {        if (char2digist(ch[index], &l))        {            *byte = l;            return 1;        }    }    return 0;    }int utf8unicode(char *src , char *out){    int bi, i, len;    unsigned int bytes[200];    int j=0, outlen =0;        bi = 0, len = strlen(src);    for (i = 0; i < len && bi < 200; ++ i)    {        if (!widechar2hexbyte(src, i++, len, &bytes[bi++]))            return 1;    }        memset(out , 0 , sizeof(out));    outlen =utf82unicode(bytes, 0, bi, out);            return outlen;    }/*---------------------------------------------------*/typedef   unsigned  short  uchar2;int Uni2UTF(uchar2 wchar, char *utf8){    if (utf8 == NULL) {        return -1;    }    int len = 0;    int size_d = 8;        if (wchar < 0x80)    {  //        //length = 1;        utf8[len++] = (char)wchar;    }    else if(wchar < 0x800)    {        //length = 2;                if (len + 1 >= size_d)            return -1;                utf8[len++] = 0xc0 | ( wchar >> 6 );        utf8[len++] = 0x80 | ( wchar & 0x3f );    }    else if(wchar < 0x10000 )    {        //length = 3;        if (len + 2 >= size_d)            return -1;                utf8[len++] = 0xe0 | ( wchar >> 12 );        utf8[len++] = 0x80 | ( (wchar >> 6) & 0x3f );        utf8[len++] = 0x80 | ( wchar & 0x3f );    }    else if( wchar < 0x200000 )    {        //length = 4;        if (len + 3 >= size_d)            return -1;                utf8[len++] = 0xf0 | ( (int)wchar >> 18 );        utf8[len++] = 0x80 | ( (wchar >> 12) & 0x3f );        utf8[len++] = 0x80 | ( (wchar >> 6) & 0x3f );        utf8[len++] = 0x80 | ( wchar & 0x3f );    }    return len;}int unicodeutf8(char *unic, int uniLen, char *utf8){    int     i, len ;    char *pUtf8 = utf8;        uchar2 *pUni =(uchar2 *)unic;        for (i =0; i< uniLen ; i=i+2 )    {        if( (len=Uni2UTF( *pUni, pUtf8 ) )<0) return -1;        pUtf8 = pUtf8+len;        pUni ++;    }        return (pUtf8 - utf8);//·µ»Øutf8³¤¶È}#endif/**检测一段Unicode字符是否为utf-8编码方式.* param : utf8nums 最大检测符合utf8的字符数 ,默认为全部都要检测*/bool isUtf8(const char *pBuf,int bufLen , unsigned int utf8numsMax  ){    int utf8Nums=0;    //符合UTF8编码的字符个数,非Ansi部分    int count=0;        while(count < bufLen-2)    {        int i=0;        while( i < bufLen-2-count)        {            if (pBuf[count+i]>0xC0)            {                if (pBuf[count+i+1]<0x80 || pBuf[count+i+1]>0xC0)                {                    return false;                }                else                {                    /*                     The transformation table for UTF-8 is presented below:                     UNICODE 	            UTF-8                     00000000 - 0000007F 	0xxxxxxx                     00000080 - 000007FF 	110xxxxx 10xxxxxx                     00000800 - 0000FFFF 	1110xxxx 10xxxxxx 10xxxxxx                          //0xE0                     00010000 - 001FFFFF 	11110xxx 10xxxxxx 10xxxxxx 10xxxxxx                 //0xF0                     00200000 - 03FFFFFF  	111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx        //0xF8                     04000000 - 7FFFFFFF 	1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx   //0xFC                     */                                        const char *tC;//target Char to 识别                                        int utfStrLen=0;                    //是否为正确的UTF8格式                    tC=pBuf+count+i;                                        if (tC[0]<=0xF0)//<4字节                        if(tC[0]>0xE0)    utfStrLen=3;                        else              utfStrLen=2;                        else if (tC[0]>=0xFC) utfStrLen=6;                        else if(tC[0]>=0xF8)  utfStrLen=5;                        else                  utfStrLen=4;                                        int k=1;                    while(k<utfStrLen)                    {                        if (!(tC[k] & 0x80 && !(tC[k]& 0x40) ))//前二位为10                        {                            return false;                        }                                                k++;                    }                                        if (k==utfStrLen)                        utf8Nums++;                    if (utf8Nums==utf8numsMax)                        return true;                }            }                        i++;        }//while( i<bufLen-2-count)                ++count;    }//while(count<bufLen-2)                return utf8Nums > 0;}//检测是否符合utf-8的编码规则.  文件里前十组符合则认为符合.ENCODETYPE TellEncodeType(char* pBuf,int bufLen){    ENCODETYPE filetype= GBK ;        if (pBuf[0]==0xFF && pBuf[1]==0xFE) //fffe,小头,windows默认        filetype=UTF16_little_endian;    else if(pBuf[0]==0xFE && pBuf[1]==0xFF )        filetype=UTF16_big_endian;    else    {                int    utf8Nums=0;    //符合UTF8编码的字符个数,非Ansi部分        int count=0;        while(count<bufLen-2)        {                        int i=0;            while( i<bufLen-2-count)            {                if (pBuf[count+i]>0xC0)                {                    if (pBuf[count+i+1]<0x80 || pBuf[count+i+1]>0xC0)                    {                        filetype=ANSI;                        break;                    }                    else                    {                        /*                         The transformation table for UTF-8 is presented below:                         UNICODE 	            UTF-8                         00000000 - 0000007F 	0xxxxxxx                         00000080 - 000007FF 	110xxxxx 10xxxxxx                         00000800 - 0000FFFF 	1110xxxx 10xxxxxx 10xxxxxx                          //0xE0                         00010000 - 001FFFFF 	11110xxx 10xxxxxx 10xxxxxx 10xxxxxx                 //0xF0                         00200000 - 03FFFFFF  	111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx        //0xF8                         04000000 - 7FFFFFFF 	1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx   //0xFC                         */                                                char *tC;//target Char to 识别                                                int utfStrLen=0;                        //是否为正确的UTF8格式                        tC=pBuf+count+i;                                                if (tC[0]<=0xF0)//<4字节                            if(tC[0]>0xE0)    utfStrLen=3;                            else              utfStrLen=2;                            else if (tC[0]>=0xFC) utfStrLen=6;                            else if(tC[0]>=0xF8)  utfStrLen=5;                            else                  utfStrLen=4;                                                int k=1;                        while(k<utfStrLen)                        {                            if (!(tC[k] & 0x80 && !(tC[k]& 0x40) ))//前二位为10                            {                                filetype=ANSI;                                break;                            }                                                        k++;                        }                                                if (k==utfStrLen)                            utf8Nums++;                        if (utf8Nums==10)                            filetype=UTF8;                    }                }                                i++;            }//while( i<bufLen-2-count)                        ++count;        }//while(count<bufLen-2)            }//else            return filetype;}#ifdef APP_PLAYER_UI#endifint hex2dec(char c){    int ret=-1;    if (c >= 'a' && c<='z')	        ret= c - 'a'+ 10;    else if (c >= 'A' && c<='Z')				        ret=c - 'A'+ 10;    else if (c >= '0' && c<='9')        ret= c - '0' ;        return ret;}#include <stdio.h>#include <string.h>//return a  char x 2char* char2hexstr(char c){    static const char hex[]="0123456789abcdef";        static char buffer[2] ;            buffer[0]=hex[c >> 4];        buffer[1]=hex[c & 0x0F];        return buffer;}//return byte changedint hexstr2mem(char *hexstr,unsigned char *mem,int meml){    //four bit ,mem to ascii table    static const char hex[]="0123456789ABCDEF";    static const char hex2[]=/*0123456789*/"abcdef";    static  char hexr[256]={1,0};//rtable    int i;    int index;    int bytes=0;    int hexstrl=strlen(hexstr);        if (1==hexr[0])    {        hexr[0]=0;        for (i=0;i<sizeof(hex)-1;++i)            hexr[hex[i]]=i;        for (i=0;i<sizeof(hex2)-1;++i)            hexr[hex2[i]]=10+i;    }        for (index=0;index<hexstrl && bytes<meml;index+=2,++bytes)        mem[bytes]= hexr[hexstr[index]]<<4 | hexr[hexstr[index+1]];    return bytes+1;}//convert to unicode text code to send in internet.//c must be unicode buffer.std::string str2UnicodeCode(const char *c,int len , bool bTing){    bool bUtf8 = isUtf8 (c , len );        char buf[200] ={0};    int bufLen;    if (bUtf8) {        bufLen = UTF8StrToUnicodeStr((unsigned char*)c,(unsigned short*)buf,200);    }            std::string tmp;            int i = 0 ;    while ( true)    {                //end when reach a null terminte '\0'        if( i%2==0 )        {            static const char ign[]=" ,./<>?`~!@#$%^&*()-_=+\\|[]{};':\"";                        //The terminating null character is considered to be part of the string; therefore if c is            //`\0', the functions locate the terminating `\0'                       char c1 = buf[i+1];            if( c1 =='\0')            {                char *p = strchr(ign , buf[i]) ;                if( p && p[0] !='\0' )                {                    i+=2;                    continue;                }            }                        //is a terminating '\0' ? 2bytes all is 00 00            uint16_t *c2 = (uint16_t *)&buf[i];            if(  *c2 == 0  )            {                break;            }        }                                    char t[10]={0};                        unsigned short int d = buf[i] & 0xff ; //char have only 4 bits                sprintf( t , "%02X", d );                //printf(  "%02X\n", d );                if(bTing)            tmp.append("%");                tmp.append(t);                ++i;    }    #ifdef DEBUG    //printf("Unicode code string : %s\n",tmp.c_str());#endif        return tmp;}/** * This file implement functions of: * * 1. UTF-16 character to UTF-8 chaaracter converting. * 2. UTF-8 character to UTF-16 character converting. * * 3. UTF-16 string to UTF-8 string converting. * 4. UTF-8 string to UTF-16 string converting. *//* Maximum bytes of a utf-8 character */#define MAX_CHARACTER_SIZE    8/** * UnicodeToUTF8 - convert unicode char to UTF-8 char * @unicode: a UNICODE(utf-16) character * @p: a buffer to contain a utf-8 characters * * @return: One step over the end of the utf-8 character buffer */unsigned char * UnicodeToUTF8( int unicode, unsigned char *p){    unsigned char *e = NULL;    if((e = p))    {        if(unicode < 0x80)        {            *e++ = unicode;        }        else if(unicode < 0x800)        {            /* <11011111> < 000 0000 0000> */            *e++ = ((unicode >> 6) & 0x1f)|0xc0;            *e++ = (unicode & 0x3f)|0x80;        }        else if(unicode < 0x10000)        {            /* <11101111> <0000 0000 0000 0000> */            *e++ = ((unicode >> 12) & 0x0f)|0xe0;            *e++ = ((unicode >> 6) & 0x3f)|0x80;            *e++ = (unicode & 0x3f)|0x80;        }        else if(unicode < 0x200000)        {            /* <11110111> <0 0000 0000 0000 0000 0000> */            *e++ = ((unicode >> 18) & 0x07)|0xf0;            *e++ = ((unicode >> 12) & 0x3f)|0x80;            *e++ = ((unicode >> 6) & 0x3f)|0x80;            *e++ = (unicode & 0x3f)|0x80;        }        else if(unicode < 0x4000000)        {            /* <11111011> <00 0000 0000 0000 0000 0000 0000> */            *e++ = ((unicode >> 24) & 0x03)|0xf8 ;            *e++ = ((unicode >> 18) & 0x3f)|0x80;            *e++ = ((unicode >> 12) & 0x3f)|0x80;            *e++ = ((unicode >> 6) & 0x3f)|0x80;            *e++ = (unicode & 0x3f)|0x80;        }        else        {            /* <11111101> <0000 0000 0000 0000 0000 0000 0000 0000> */            *e++ = ((unicode >> 30) & 0x01)|0xfc;            *e++ = ((unicode >> 24) & 0x3f)|0x80;            *e++ = ((unicode >> 18) & 0x3f)|0x80;            *e++ = ((unicode >> 12) & 0x3f)|0x80;            *e++ = ((unicode >> 6) & 0x3f)|0x80;            *e++ = (unicode & 0x3f)|0x80;        }    }    /* Return One step over the end of the utf-8 character buffer */    return e;}/** * UTF8ToUnicode - convert UTF-8 char to unicode char * @ch: A buffer contain a utf-8 character * @unicode: Contain the converted utf-16 character * * @return: Bytes count of the utf-8 character (1 ~ 6), *          can be used to step to next utf-8 character when convert a utf-8 string to a utf-16 string */int UTF8ToUnicode (unsigned char *ch, int *unicode){    unsigned char *p = NULL;    int e = 0, n = 0;    if((p = ch) && unicode)    {        if(*p >= 0xfc)        {            /* 6:<11111100> */            e = (p[0] & 0x01) << 30;            e |= (p[1] & 0x3f) << 24;            e |= (p[2] & 0x3f) << 18;            e |= (p[3] & 0x3f) << 12;            e |= (p[4] & 0x3f) << 6;            e |= (p[5] & 0x3f);            n = 6;        }        else if(*p >= 0xf8)        {            /* 5:<11111000> */            e = (p[0] & 0x03) << 24;            e |= (p[1] & 0x3f) << 18;            e |= (p[2] & 0x3f) << 12;            e |= (p[3] & 0x3f) << 6;            e |= (p[4] & 0x3f);            n = 5;        }        else if(*p >= 0xf0)        {            /* 4:<11110000> */            e = (p[0] & 0x07) << 18;            e |= (p[1] & 0x3f) << 12;            e |= (p[2] & 0x3f) << 6;            e |= (p[3] & 0x3f);            n = 4;        }        else if(*p >= 0xe0)        {            /* 3:<11100000> */            e = (p[0] & 0x0f) << 12;            e |= (p[1] & 0x3f) << 6;            e |= (p[2] & 0x3f);            n = 3;        }        else if(*p >= 0xc0)        {            /* 2:<11000000> */            e = (p[0] & 0x1f) << 6;            e |= (p[1] & 0x3f);            n = 2;        }        else        {            e = p[0];            n = 1;        }        *unicode = e;    }    /* Return bytes count of this utf-8 character */    return n;}/** * UnicodeStrToUTF8Str - Convert a utf-16 string to a utf-8 string * @unicde_str: A utf-16 string * @utf8_str: A buffer to contain utf-8 string * @utf8_str_size: Maximum size of the utf-8 string buffer * * @return: One step over the end of the last utf-8 character */unsigned char * UnicodeStrToUTF8Str (unsigned short * unicode_str,                                     unsigned char * utf8_str, int utf8_str_size){    int unicode = 0;    unsigned char *e = NULL, *s = NULL;    unsigned char utf8_ch[MAX_CHARACTER_SIZE];    s = utf8_str;    if ((unicode_str) && (s))    {        while ((unicode = (int) (*unicode_str++)))        {            memset (utf8_ch, 0, sizeof (utf8_ch));                        if ((e = UnicodeToUTF8 (unicode, utf8_ch)) > utf8_ch)            {                *e = '/0';                                /* Judge whether exceed the destination buffer */                if ((s - utf8_str + strlen ((const char *) utf8_ch)) >= utf8_str_size)                {                    return s;                }                else                {                    memcpy (s, utf8_ch, strlen ((const char *) utf8_ch));                    s += strlen ((const char *) utf8_ch);                    *s = '/0';                }            }            else            {                /* Converting error occurs */                return s;            }        }    }        return s;}/** * UTF8StrToUnicodeStr - Convert a utf-8 stirng to a utf-16 string * @utf8_str: A utf-8 string * @unicode_str: A buffer to contain utf-16 string * @unicode_str_size: Maximum size of the utf-16 string buffer * * @return: Number of utf-16 character */int UTF8StrToUnicodeStr (unsigned char * utf8_str,                         unsigned short * unicode_str, int unicode_str_size){    int unicode = 0;    int n = 0;    int count = 0;    unsigned char *s = NULL;    unsigned short *e = NULL;        s = utf8_str;    e = unicode_str;        if ((utf8_str) && (unicode_str))    {        while (*s)        {            if ((n = UTF8ToUnicode (s, &unicode)) > 0)            {                count += n;                                if ((count + 1) >= unicode_str_size)                {                    return count;                }                else                {                    *e = (unsigned short) unicode;                    e++;                    *e = 0;                                        /* Step to next utf-8 character */                    s += n;                }            }            else            {                /* Converting error occurs */                return count;            }        }    }        return count;}